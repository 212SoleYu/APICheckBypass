# Overview

本文档用于对各类的bug pattern作进一步的解释, 尤其是涉及了复杂特性的函数

## Type

### Description

Type类型中有若干个函数来自泛指针类型, 包括Box, Rc, Arc等, 其中unsafe API一些是指针类型的方法, 一些是对应trait的trait function.

其中有接近十个是downcast相关, 对于这些unsafe函数, 在源代码层面的安全条件统一是: 

```rust
/// The contained value must be of type `T`. Calling this method
/// with the incorrect type is *undefined behavior*.
```

但是有一个困惑在于: 这个类型T是谁的类型?

---

首先, 不管是类型方法还是trait function, 这些downcast相关的函数都是类似的, 就是将这个指针指向的类型转换为该类型(看似自我绕圈的解释), 是因为dyn Any本身就是一种类型, 一个指针指向一个dyn Any的类型值, 希望通过downcast::\<u32\>进行转换为u32, 就算转换之气那他事实上就是一个u32的字面值, 他在类型系统中仍然是dyn Any类型. 所以, 才会有所谓的"确保类型正确"

下面贴一个例子, 转换的正确与否带来的未定义行为: 

```rust
let a:u32= 2111;
let b: Box<dyn Any + Send + Sync> = Box::new(a);
println!("{:?}",b.type_id());
unsafe {
    let res = b.downcast_unchecked::<u8>();
    println!("{:?}",res);
}
```

 上段代码的输出为:

```rust
TypeId(0xf97c56165baf508f48ef7ff45d47c01d)
63
```

可以看到, u32类型被强制转换为u8后发生了数据溢出. 如果将其转换为string等更复杂的类型, 会导致更严重的未定义行为.

---

总结, 所有downcast相关的函数, 需要保证的是, 通过downcast::\<T\>进行显式类型转换的类型是否真的是实质上的类型

---

那么进一步的问题就又来了, 在MIR层面, 是否能识别函数签名中的T? 怎么识别指针指向的变量的事实上的值? 这个也许要在实际代码中找真正的代码进行研究了.

但是不可否认的, Type类型的safe/unsafe API group仍然是一类很重要的分类

### Method

关于Type类型, 需要判断当前给定的转换目标类型是否是真正正确的类型, 那么比如downcast函数是常见的, 在mir层面, 或者是其他层面, 能否识别出这样显示的函数语句?(downcast::<\u32>, for example)

假定可以的话, 转换的类型可知, 那么期待的类型如何获知? Rust的类型推断在MIR层面是如何进行的呢?

## Intrinsic/Unexposed

### Description

内置类型包含了一大类, 后续这部分应该会被调整至所有的不可见类型

内置类型(不可见类型) 仍然会被检索到的原因是 虽然函数使用pub进行修饰, 但是所在的模块没有被连续传播到用户层面, 或者没有被重新导出等, 但是该类型的函数中很大一部分会被其他的safe/unsafe API调用, 但是在我们的工作中不进行过多考虑.

### Method

我们对这些方法不做替换方法的设计.

## Result/Option

### Description

这类强针对Rust中特有的枚举类型Result和Option, 判断枚举类型中内含的对象是否是Ok或者Some.

### Method

这个子问题的研究要联想到之前对于Result/Option类型unwrap操作的的跨函数分析的思考中, 怎么去追溯一个枚举类型是否是安全的:

1. 之前的思考是, 一个位置是安全的, 那么就可以将panic报告过滤; 现在改成了, 如果一个位置是安全的, 那么就可以将此处的unwrap修改成unwrap_unchecked等.
2. 之前考虑过定位枚举类型出现的地方, 现在要考虑的是出现unwrap函数的地方(unwrap函数一定是常见的).

## Nullptr

### Description

针对裸指针等, 需要判断其进入的参数是否是一个空指针, 能否让其进行安全的初始化或者返回引用.

### Method

需要理清: 

1. 在MIR层面, 指针类型怎么表示? 空指针的这个值是如何检测?
2. 老问题, 我们发现某处有一个与空指针检测相关的API, 怎么对其进行往前的分析?其传入的指针在何处生成, 一路上怎么传播才到这里来

## Complex

### Description

在Complex中有很多类型的问题, 但是不能组成一个共通的大类,例如

1. Btree结构体相关的, 虽然应该是很常见, 但是其安全条件是需要键不重复
2. 一些vector相关的, 要求向量中所有的值都是0或者-1
3. 一些pin相关和线程和智能指针相关
4. 一些指针解引用和偏移位置是否越界相关

### Method

作为一个杂类, 可能将其中某一些单独处理, 放在最后考虑

## Numerical

下面四个大类, 其都与数值运算相关, 可以通过数值分析进行, 因为整数的溢出, 非零, 数组访问的越界, 字符码集的越界,都是可以通过这样数值分析的方法来解决的, 此处可以详情参考MirChecker, 仿照他的分析方法来实现我们的方法

### CString

与CString相关的类型, 其实很多都是在转换字符串的过程中检查是否存在空字节, 或者说是否在某个编码集合范围中.

### Overflow

多是数据类型方法中的算术运算, 需要保证运算前后不会发生溢出, 可能需要抽象解释

### Nonzero

检测参数非零, 与数值分析很相近

### Index

目前最主要的一类, 包括但不限于检测是否是数组越界, 是否是ascii码, 还有一些检测是否是2的幂, 都是需要数值分析

### Method

关于数值分析, 是可以按照常规静态分析的方法从头到尾标记每一个变量的数值的, 通过抽象解释的方法来对其进行数值分析, 但是可能的问题在于, 

1. 例如越界的问题, 有的越界是动态的越界,例如一个vec的get_mut方法, 有的越界是静态的,例如对于静态数组的访问还有一些字符是否属于相同的字符码集合; 
2. 又或者对于越界和非零问题等, 
3. 虽然他们都可以通过数值分析来进行, 但是其进行分析的时候所需要的抽象类型不同, 有的需要抽象到边界, 有的需要抽象到正负0等, 有的需要抽象到是否溢出.

此处可以先回头去看MirChecker中的数值分析, 或者直接去找数值分析相关的文章和介绍.